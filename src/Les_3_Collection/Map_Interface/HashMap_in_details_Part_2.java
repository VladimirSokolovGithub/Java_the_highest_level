package Les_3_Collection.Map_Interface;

import java.util.HashMap;
import java.util.Map;

public class HashMap_in_details_Part_2 {

    public static void main(String[] args) {

        //При создании объекта HashMap мы можем указать такие параметры как:
        //1. initialCapacity - начальный размер массива.
        //2. loadFactor - коэффициент того, насколько массив должен быть заполнен, после чего его размер
        //будет увеличен вдвое.
        //Расчитывается это так: 16 * 0,75 = 12 - т.е после того, как в наш HashMap будет добавлено 12 элементов
        //размер нашего массива будет увеличен вдвое. Появится массив из 32 элементов и все элементы HashMap
        //будут рехешированны т.е. согласно хешу, который содержит Нода будет определяться на какой индекс нового
        //массива будет определен тот или иной элемент.
        //Чем больше будет значение initialCapacity, тем больше памяти будет занимать массив, но тем меньше
        //LinkedList-ы будут образовываться в этом массиве и тем быстрее будет проходить поиск элемента

        //Соответственно чем больше loadFactor, тем больше мы будем экономить памяти, но поиск будет занимать
        //дольше времени

        // в java 8 - после достижения определенного порога вместо связанных списков LinkedList, используются
        //сбалансированные деревья.

        //В сбалансированном дереве справа всегда находится больший элемент, слева меньший(есть схема)
        //Это помогает достичь скорости O(log n), так как в сбалансированном дереве идёт бинарный поиск.

        Map<Integer, String> map2 = new HashMap<>(16, 0.75f); //это дефолтные значения


        //Так же очень важно в качестве значение ключа key использовать Immutable объекты это достигается
        //с помощью модификатора final. Если брать на примере класса Student, то поставить для каждого поля
        //final и так же сделать класс final что бы он не мог иметь наследников.

        Map<Student, Double> map3 = new HashMap<>();
        Student st1 = new Student("Vladimir", "Sokolov", 3);
        Student st2 = new Student("Mariya", "Ivanova", 1);
        Student st3 = new Student("Sergey", "Petrov", 4);
        map3.put(st1, 7.5);
        map3.put(st2, 8.7);
        map3.put(st3, 9.2);
        System.out.println(map3);
        //Проверим, содержит ли наш HashMap ключ st1
        System.out.println(map3.containsKey(st1));  //true
        //допустим для st1 мы изменим курс
        System.out.println(st1.hashCode());
        st1.course = 4;
        //Проверим, ещё раз содержит ли наш HashMap ключ st1
        System.out.println(map3.containsKey(st1)); //false
        System.out.println(st1.hashCode());
        //Это произошло потому что course участвует в нашем методе hashCode().
        //В зависимости от имени, фамилии и курса расчитывается наш хеш код и возвращается какой-то int, а
        //здесь мы меняем course и потом когда мы с помощью метода get() будем искать ключ в нашем HashMap
        //хеш код этого ключа будет уже совершенно другим, а не таким каким он был для этого студента.
        //Таким образом объект этого ключа должен быть Immutable, так же делать инкапсуляцию -
        // все поля private и добавлять только геттеры.

        //HashMap - это коллекция not synchronized и её не нужно использовать в многопоточном программировании,
        //для этого есть коллекция concurrent HashMap

    }
}
